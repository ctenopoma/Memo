---
marp: true
html: true
size: 16:9
theme: classmethod
paginate: true
---

<!-- _class: title　-->
<!-- _paginate: false -->

##

# レガシーコードに対するコーディングAI適用戦略

2026年1月28日

<small>所属</small>

---

## 1. プロジェクトの全体像（ロジックフロー）

本プロジェクトは、レガシーコードが抱える事業的・技術的課題を、**「AI/RAG技術」** と **「適切なプロセス」** の組み合わせによって解決し、ROIを最大化することを目的とする。

1. **課題 (Problem):** 属人化、ブラックボックス化、資産の死蔵
2. **打ち手 (Solution):** 単位の定義、Living GraphRAG、テスト駆動リファクタリング
3. **利益 (Benefit):** 維持コスト削減、開発スピード向上、資産再利用
4. **立証 (Proof):** 技術指標と事業KPIによるROI測定

---

# 1. 現状と課題 (Problem)

---

# 事業的課題：レガシーコードの限界

**状況:** 仕様書なし・テストなし・理解者不在の「三重苦」

| 課題カテゴリ    | 具体的な痛み (Pain Points)                                                                   |
| :-------------- | :------------------------------------------------------------------------------------------- |
| **1. 人材枯渇** | 古い言語を扱えるエンジニアが不在。手動維持が限界。                                           |
| **2. 変更困難** | 影響範囲が見えず、機能追加がギャンブル化。<br>調査に膨大な工数がかかる。                     |
| **3. 資産死蔵** | 過去の有用なビジネスロジックが密結合で埋没。<br>新規開発で再利用できず、車輪の再発明が発生。 |

---

# 技術的課題：既存AI適用の壁

単に「コードをAIに読ませる」だけでは解決できない技術的障壁がある。

1. **コンテキストの限界 (Context Window)**
    * 一度に読める量に制限があり、全体構造や依存関係を把握できない。
2. **ハルシネーション (Hallucination)**
    * 存在しないライブラリの使用や、嘘の仕様を回答するリスク。
3. **レビューのボトルネック**
    * AIの生成速度に人間が追いつけず、**「誰も理解できないコード」**が再生産される。
4. **解析の難易度**
    * レガシーコード（動的型付け・GOTO文）は静的解析（AST）が困難。

---

# 2. 解決策と仮説 (Solution & Hypothesis)

---

# 提案手法：4段階の適用プロセス

技術的課題を突破し、事業課題を解決するための実行プロセス。

1. **【定義】単位策定:** AIと人が扱える「最小単位」を定義。
2. **【切出】セグメンテーション:** 依存解析によりレガシーコードを「単位」に分割。
3. **【構築】Living GraphRAG:** 構造と意味を理解する動的DBの構築。
4. **【実行】Test → Refactor → Harvest:** 安全圏を確保した開発と資産化。

---

# 技術的な打ち手：課題へのカウンターメジャー

| 課題           | 打ち手 (Countermeasure)                                | 効果 (Hypothesis)                                              |
| :------------- | :----------------------------------------------------- | :------------------------------------------------------------- |
| **解析困難**   | **ハイブリッド解析**<br>(耐障害パーサー + LLM意味解析) | 構文エラーがあるコードでも<br>構造化・検索可能にする。         |
| **隠れた依存** | **動的トレーシング & コンテキスト注入**                | グローバル変数等の副作用を<br>AIに認識させ、整合性を保つ。     |
| **陳腐化**     | **Living Documentation**<br>(CI/CD連携による差分更新)  | 常に最新のコードと仕様が<br>同期し、ハルシネーションを防ぐ。   |
| **正解不在**   | **As-Isテスト (現行踏襲)**                             | 「仕様の正しさ」より「挙動の変化」<br>を検知し、デグレを防ぐ。 |

---

# 3. 実施事項

---

# Step 1 & 2: 単位定義と切り出し戦略

**AIと人が「確実に扱えるサイズ」まで問題を小さくする。**

* **AIの単位:**
  * コンテキスト溢れを起こさないトークン量（例: 500行以内）。
* **人の単位:**
  * 認知負荷を超えないレビュー範囲（単一責任）。
* **セグメンテーション:**
  * 静的・動的解析で「縫い目（Seams）」を見つけ、巨大クラスを分割戦略を立てる。

---

# Step 3: "Living" GraphRAG の構築

**「死んだドキュメント」ではなく、「コードと会話できる脳」を作る。**

* **構造化 (Hybrid Indexing):**
  * 依存関係（Call Graph） + 意味的類似性（Vector）でDB化。
* **動的同期 (Sync):**
  * Git Commitをトリガーに差分のみを即座にDB反映。
* **効果:**
  * 「この変更の影響範囲は？」等の高度な質問に即答可能に。

---

# Step 4: リファクタリングと「資産化」

**守り（テスト）を固めてから、攻め（改修・抽出）を行う。**

1. **(Test) 防御:**
    * 現行挙動を100%再現するテストをAI生成（As-Is保証）。
2. **(Refactor) 改善:**
    * テスト保護下で、可読性向上・モダン言語への移行。
3. **(Harvest) 収穫:**
    * **重要:** ビジネスロジックを依存から切り離し、**「再利用可能な部品」**として登録。
4. **(Future) 発展:**
    * SPL（プロダクトライン）分析、可観測性の自動注入へ。

---

# 4. 評価とROI (Evaluation)

---

## 技術的評価：ツールの有効性

AIが正しく機能し、品質を担保できているか？

| 視点         | KPI (指標)              | 評価目的                           |
| :----------- | :---------------------- | :--------------------------------- |
| **AI精度**   | **Pass@1** (一発成功率) | AIの実装能力の検証。               |
| **安全性**   | **回帰テスト通過率**    | リファクタリングによるデグレ阻止。 |
| **構造改善** | **結合度 / 凝集度**     | スパゲッティコードの解消度合い。   |
| **RAG品質**  | **Context Precision**   | 正確な情報を検索できているか。     |

---

# 事業的評価：ビジネスインパクト (1/2)

**「誰が楽になり、何が早くなったか」**

| 課題領域 | KPI                                            | 測定の狙い                                                 |
| :------- | :--------------------------------------------- | :--------------------------------------------------------- |
| **人材** | **バス係数の向上**<br>オンボーディング時間短縮 | 特定のベテラン依存からの脱却。<br>若手・他言語話者の参画。 |
| **速度** | **変更リードタイム**<br>調査工数の削減率       | 「調査3日→3時間」のような<br>劇的なスピードアップの立証。  |

**「資産化」の質と再利用効果**

| 課題領域     | KPI                                   | 測定の狙い                                                     |
| :----------- | :------------------------------------ | :------------------------------------------------------------- |
| **再利用**   | **工数削減額 (Cost Avoidance)**       | 新規開発で部品を使い回せた金額効果。                           |
| **資産品質** | **独立性スコア & ドキュメント完備率** | **「使える資産」**だけが登録されているか。<br>(ゴミ資産の防止) |
| **市場**     | **Time-to-Market 短縮**               | 複雑なロジックを流用し、リリースを早める。                     |

---

# 結論：ROI (投資対効果) の最大化

本戦略の妥当性は、以下の式で証明される。

$$
\text{ROI} = \frac{\text{削減された維持費} + \text{回避できた開発費} + \text{リスク低減}}{\text{AI導入・運用コスト}}
$$

**結論:**
単なるコード修正ではなく、**「レガシーコードを資産（Asset）に変え、継続的なビジネス価値を生むシステム」**へと昇華させる。

---

# 補足① トークン長（コンテキストウィンドウ）の制限

ローカル環境のハードウェア制約（主にVRAM）により、プロンプトとして入力できる情報量に物理的な限界があることによる課題。

| ID   | プロセス / 機能      | 故障モード (Failure Mode)               | 影響 (Effect)                                                                        | 原因 (Cause)                                                                            | S    | O    | D    | **RPN** | 推奨される対策・緩和策                                                                                                               |
| :--- | :------------------- | :-------------------------------------- | :----------------------------------------------------------------------------------- | :-------------------------------------------------------------------------------------- | :--- | :--- | :--- | :------ | :----------------------------------------------------------------------------------------------------------------------------------- |
| A-1  | **コード読解・要約** | **コンテキストの断絶・忘却**            | 依存関係にある関数の定義や変数の型を見落とし、既存コードと矛盾した実装を行う。       | VRAM不足によるモデルのコンテキスト長制限超過。入力情報の切り捨て（Truncation）。        | 6    | 8    | 3    | **144** | ・RAG（検索拡張生成）による関連情報の動的抽出<br>・スライディングウィンドウ方式の実装<br>・Tree-sitter等を用いた重要コードの優先抽出 |
| A-2  | **リファクタリング** | **指示の途中消失 (Lost in the Middle)** | 「変数名はキャメルケース」等のスタイル指示や制約事項が、長文入力の後半で無視される。 | 注意機構（Attention）の精度低下。特にプロンプトの中間部分の情報が重視されなくなる現象。 | 3    | 6    | 2    | **36**  | ・System Promptによる指示の再注入<br>・処理単位の細分化（ファイル単位ではなく関数単位で処理）                                        |

---

# 補足②ハルシネーション（幻覚）

ローカルモデル（7B〜30B程度）の知識量・推論能力の限界により、事実に基づかない、または論理的に誤ったコードを生成する課題。

| ID   | プロセス / 機能    | 故障モード (Failure Mode)    | 影響 (Effect)                                                                                        | 原因 (Cause)                                                                     | S     | O    | D    | **RPN** | 推奨される対策・緩和策                              |
| :--- | :----------------- | :--------------------------- | :--------------------------------------------------------------------------------------------------- | :------------------------------------------------------------------------------- | :---- | :--- | :--- | :------ | :-------------------------------------------------- |
| B-1  | **ライブラリ使用** | **存在しない関数の捏造**     | 実在しないメソッド（例: `date.to_japan_format()`）を提案し、実行時エラーを引き起こす。               | 学習データの不足による確率的な穴埋め。バージョン違いの知識の混同。               | 4     | 7    | 2    | **56**  | ・RAGによる公式ドキュメントの参照強制<br>           |
| B-2  | **ロジック実装**   | **脆弱性の混入**             | SQLインジェクション、XSS、ハードコードされた認証情報など、セキュリティリスクのあるコードを生成する。 | 安全性を判断する論理的推論能力の不足。学習データに含まれる低品質なコードの再現。 | **9** | 3    | 8    | **216** | ・人間によるコードレビューの義務化                  |
| B-3  | **デバッグ支援**   | **誤った原因・修正案の提示** | エラーログに対して無関係な修正案を提示し、デバッグ作業を混乱・遅延させる。                           | エラーメッセージとコードの因果関係推論の失敗。                                   | 5     | 5    | 5    | **125** | ・CoT（Chain of Thought）プロンプトによる段階的推論 |

---

# 補足③：人のレビュー困難性により生じる課題(mind-map)

![height:500px](image.png)
